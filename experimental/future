#pragma once

#include <experimental/optional>
#include <experimental/variant>
#include <type_traits>
#include <utility>
#include <exception>
#include <stdexcept>
#include <system_error>
#include <mutex>
#include <condition_variable>

// XXX for now, we don't bother implementing a different std::experimental::v1::future_error
//     so #include <future> to get access to std::future_error
//     should check if the Concurrency TS specifies a different, experimental one
#include <future>

namespace std
{
namespace experimental
{
inline namespace v1
{
namespace detail
{


// this is the type of future produced by std::async(std::launch::deferred, ...)
template<class T>
class deferred_future;


// this is the type of future produced by std::async(std::launch::async, ...) and std::promise::get_future()
template<class T>
class asynchronous_state
{
  private:
    bool unsafe_ready() const
    {
      return maybe_result_.has_value();
    }

  public:
    bool ready() const
    {
      std::lock_guard<std::mutex> guard(mutex_);

      return unsafe_ready();
    }

    void set_value(const T& value)
    {
      std::lock_guard<std::mutex> guard(mutex_);

      maybe_result_ = variant_type(value);
    }

    void set_value(T&& value)
    {
      std::lock_guard<std::mutex> guard(mutex_);

      maybe_result_ = variant_type(std::move(value));
    }

    void set_exception(std::exception_ptr e)
    {
      std::lock_guard<std::mutex> guard(mutex_);

      maybe_result_ = variant_type(e);
    }

    void wait() const
    {
      std::unique_lock<std::mutex> lock(mutex_);
      condition_variable_.wait(lock, [this]{ return unsafe_ready(); });
    }

  private:
    struct get_visitor
    {
      T operator()(T& value) const
      {
        return std::move(value);
      }

      T operator()(std::exception_ptr e) const
      {
        std::rethrow_exception(e);
      }
    };

  public:
    T get()
    {
      // wait for readiness
      wait();

      // get the result or throw any exception
      T result = std::experimental::visit(get_visitor(), *maybe_result_);

      // invalidate ourself
      maybe_result_ = nullopt;

      // return the result
      return result;
    }

  private:
    // these are mutable because .wait() is supposed to be const
    mutable std::condition_variable condition_variable_;
    mutable std::mutex mutex_;

    using variant_type = std::experimental::variant<T, std::exception_ptr>;
    std::experimental::optional<variant_type> maybe_result_;
};


template<class T>
class async_future
{
  public:
    async_future(std::shared_ptr<asynchronous_state<T>> ptr_to_state)
      : ptr_to_state_(ptr_to_state)
    {}

    async_future() noexcept = default;

    async_future(async_future&& other) noexcept
      : ptr_to_state_(std::move(other.ptr_to_state_))
    {}

    async_future(const async_future&) = delete;

    async_future& operator=(async_future&& other) noexcept
    {
      bool expected_valid = other.valid();

      ptr_to_state_ = std::move(other.ptr_to_state_);

      assert(!other.valid());
      assert(valid() == expected_valid);

      return *this;
    }

    T get()
    {
      if(!valid())
      {
        // XXX we are encouraged to throw an exception here
      }

      T result = ptr_to_state_->get();

      // invalidate ourself
      ptr_to_state_ = nullptr;

      return result;
    }

    bool valid() const noexcept
    {
      return ptr_to_state_ != nullptr;
    }

    void wait() const
    {
      if(!valid())
      {
        // XXX throw exception here
      }

      ptr_to_state_->wait();
    }

    // XXX TODO wait_for()

    // XXX TODO wait_until()

  private:
    // XXX shared_ptr is probably overkill because there will only ever be
    //     at most two owners of the asynchronous state
    std::shared_ptr<asynchronous_state<T>> ptr_to_state_;
};


// this is the type of future produced by make_ready_future()
template<class T>
class made_ready_future
{
  public:
    // this constructor corresponds to an overload of promise::set_value()
    made_ready_future(const T& value) noexcept
      : maybe_result_(variant_type(value))
    {}

    // this constructor corresponds to an overload of promise::set_value()
    made_ready_future(T&& value) noexcept
      : maybe_result_(variant_type(std::move(value)))
    {}

    // this constructor corresponds to promise::set_exception
    made_ready_future(std::exception_ptr e) noexcept
      : maybe_result_(variant_type(e))
    {}

    made_ready_future(made_ready_future&& other) noexcept
      : maybe_result_(std::move(other.maybe_result_))
    {
      // invalidate the other future
      other.maybe_result_ = nullopt;
    }

    made_ready_future& operator=(made_ready_future&& other) noexcept
    {
      bool expected_valid = other.valid();

      // move the other's result
      maybe_result_ = std::move(other.maybe_result_);

      // invalidate the other future
      other.maybe_result_ = std::experimental::nullopt;

      assert(!other.valid());
      assert(valid() == expected_valid);

      return *this;
    }

  private:
    struct get_visitor
    {
      T operator()(T& value) const
      {
        return std::move(value);
      }

      T operator()(std::exception_ptr e) const
      {
        std::rethrow_exception(e);
      }
    };

  public:
    T get()
    {
      // get the result or throw any exception
      T result = std::experimental::visit(get_visitor(), *maybe_result_);

      // invalidate ourself
      maybe_result_ = nullopt;

      // return the result
      return result;
    }

    bool valid() const noexcept
    {
      return maybe_result_.has_value();
    }

  private:
    using variant_type = std::experimental::variant<T, std::exception_ptr>;

    std::experimental::optional<variant_type> maybe_result_;
};


} // end detail


// declare future so that the functions below can return it
template<class T>
class future;

// declare these functions and types so that future can friend them
template<class T>
future<T> make_exceptional_future(std::exception_ptr e);

template<class T>
future<typename std::decay<T>::type> make_ready_future(T&& value);

template<class T>
class promise;


template<class T>
class future
{
  public:
    future() noexcept
      : variant_()
    {}

    // XXX TODO share()
    
  private:
    struct get_visitor
    {
      template<class Future>
      T operator()(Future& f) const
      {
        return f.get();
      }
    };

  public:
    T get()
    {
      return std::experimental::visit(get_visitor(), variant_);
    }

  private:
    struct valid_visitor
    {
      template<class Future>
      bool operator()(const Future& f) const
      {
        return f.valid();
      }
    };

  public:
    bool valid() const noexcept
    {
      return std::experimental::visit(valid_visitor(), variant_);
    }

  private:
    struct wait_visitor
    {
      template<class Future>
      void operator()(const Future& f) const
      {
        f.wait();
      }
    };

  public:
    void wait() const
    {
      std::experimental::visit(wait_visitor(), variant_);
    }

  private:
    friend promise<T>;

    future(detail::async_future<T>&& value)
      : variant_(std::move(value))
    {}

    friend future<T> make_exceptional_future<T>(std::exception_ptr e);

    friend future<typename std::decay<T>::type> make_ready_future<T>(T&& value);

    future(detail::made_ready_future<T>&& value)
      : variant_(std::move(value))
    {}

    using variant_type = std::experimental::variant<
      detail::async_future<T>,
      detail::made_ready_future<T>
    >;

    variant_type variant_;
};


template<class T>
class promise
{
  public:
    promise()
      : ptr_to_state_(std::make_shared<detail::asynchronous_state<T>>())
    {}

    promise(const promise&) = delete;

    promise(promise&& other)
      : ptr_to_state_(std::move(other.ptr_to_state_))
    {}

    promise& operator=(promise&& other) noexcept
    {
      promise(std::move(other)).swap(*this);
    }

    promise& operator=(const promise&) = delete;

    void swap(promise& other) noexcept
    {
      ptr_to_state_.swap(other.ptr_to_state_);
    }

    future<T> get_future()
    {
      if(ptr_to_state_ == nullptr)
      {
        throw std::future_error(std::future_errc::no_state);
      }

      if(future_retrieved())
      {
        throw std::future_error(std::future_errc::future_already_retrieved);
      }

      future<T> result = detail::async_future<T>(ptr_to_state_);

      // if the promise is satisfied, then we can release the state
      if(promise_satisfied())
      {
        ptr_to_state_ = nullptr;
      }

      return result;
    }

    void set_value(const T& value)
    {
      if(ptr_to_state_ == nullptr)
      {
        throw std::future_error(std::future_errc::no_state);
      }

      if(promise_satisfied())
      {
        throw std::future_error(std::future_errc::promise_already_satisfied);
      }

      ptr_to_state_->set_value(value);

      // if the future is retrived, then we can release the state
      if(future_retrieved())
      {
        ptr_to_state_ = nullptr;
      }
    }

    void set_value(T&& value)
    {
      if(ptr_to_state_ == nullptr)
      {
        throw std::future_error(std::future_errc::no_state);
      }

      if(ptr_to_state_->ready())
      {
        throw std::future_error(std::future_errc::promise_already_satisfied);
      }

      ptr_to_state_->set_value(std::move(value));

      // if the future is retrived, then we can release the state
      if(future_retrieved())
      {
        ptr_to_state_ = nullptr;
      }
    }

    void set_exception(std::exception_ptr p)
    {
      if(ptr_to_state_ == nullptr)
      {
        throw std::future_error(std::future_errc::no_state);
      }

      if(ptr_to_state_->ready())
      {
        throw std::future_error(std::future_errc::promise_already_satisfied);
      }

      ptr_to_state_->set_exception(p);

      // if the future is retrived, then we can release the state
      if(future_retrieved())
      {
        ptr_to_state_ = nullptr;
      }
    }

  private:
    bool future_retrieved() const
    {
      return ptr_to_state_.use_count() > 1;
    }

    bool promise_satisfied() const
    {
      return ptr_to_state_->ready();
    }

    std::shared_ptr<detail::asynchronous_state<T>> ptr_to_state_;
};


template<class T>
future<typename std::decay<T>::type> make_ready_future(T&& value)
{
  return detail::made_ready_future<typename std::decay<T>::type>(std::forward<T>(value));
}


template<class T>
future<T> make_exceptional_future(std::exception_ptr e)
{
  return detail::made_ready_future<T>(e);
}


template<class T, class E>
future<T> make_exceptional_future(E ex)
{
  return std::experimental::make_exceptional_future<T>(std::make_exception_ptr(ex));
}


} // end v1
} // end experimental
} // end std

